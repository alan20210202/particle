<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">//! # Particle - A practice in writing parser gens</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! A hobby project as I learn compiler theory as well as rust.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Planned Features</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Currently there exists two major form of parser gens:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! 1. Parser gens like Yacc(or Bison), ANTLR and JavaCC needs developers to write an external syntax description file which will then be converted into source code by these generators. These generators are indeed fancy and powerful, but its relatively hard to customize.</span>
<span class="doccomment">//! 2. Parser combinators are good, intuitive and simple, they do not require developer to write external files, instead, syntax rules are encoded in the source code directly. That being said, since parser combinators are &quot;combinators&quot;, each of the combinator cannot really have a big picture of the source being parsed, therefore error handling can be hard.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Particle aims to be the hybrid of two forms listed above, to be exact, it is designed to be:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! 1. No external description files. Just put your syntax rules in the source code.</span>
<span class="doccomment">//! 2. Fast. This is why I choose Rust as the language instead of Java or Go.</span>
<span class="doccomment">//! 3. One-stop. Particle will cover both lexers and parsers. If possible, auto bindings to AST elements will be available too.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Currently implemented Features</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! 1. Parse from simple regular expressions (no captures) to NFAs.</span>
<span class="doccomment">//! 2. Subset construction algorithm to convert NFAs to DFAs.</span>
<span class="doccomment">//! 3. Hopcroft algorithm for DFA minimization.</span>
<span class="doccomment">//! 4. Lexer construction</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Example</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! This annotated example shows a simple lexer parsing simple expressions:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! use particle::define_lexer;</span>
<span class="doccomment">//! use particle::lexer::LexerState;</span>
<span class="doccomment">//! use particle::span::Span;</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! /// Four kinds of tokens</span>
<span class="doccomment">//! #[derive(Debug)]</span>
<span class="doccomment">//! enum TokenKind {</span>
<span class="doccomment">//!     Punctuation(String),</span>
<span class="doccomment">//!     Integer(i32),</span>
<span class="doccomment">//!     Float(f64),</span>
<span class="doccomment">//!     Identifier(String),</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! /// A Token object with locational information (span)</span>
<span class="doccomment">//! #[derive(Debug)]</span>
<span class="doccomment">//! struct Token {</span>
<span class="doccomment">//!     span: Span,</span>
<span class="doccomment">//!     kind: TokenKind,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! fn main() {</span>
<span class="doccomment">//!     // Define our lexer.</span>
<span class="doccomment">//!     // `Token` below denotes the type of token this lexer is going to return.</span>
<span class="doccomment">//!     let lexer = define_lexer!(Token =</span>
<span class="doccomment">//!         // Discard white spaces</span>
<span class="doccomment">//!         discard &quot;[ \n\r\t]+&quot;,</span>
<span class="doccomment">//!         // Integers</span>
<span class="doccomment">//!         // The expression after =&gt; is a function that takes the token string as</span>
<span class="doccomment">//!         // well as the span and returns the result (of type specified above, or</span>
<span class="doccomment">//!         // Token in this case).</span>
<span class="doccomment">//!         &quot;[1-9][0-9]*&quot;                                   =&gt; |s, span| Token { span,</span>
<span class="doccomment">//!             kind: TokenKind::Integer(s.parse().unwrap()),</span>
<span class="doccomment">//!         },</span>
<span class="doccomment">//!         // Floats with exponents</span>
<span class="doccomment">//!         // Notice that the regex above also matches integers, which lead to ambiguity.</span>
<span class="doccomment">//!         // Such ambiguity is solved by preferring rules that are defined first</span>
<span class="doccomment">//!         // So you should somehow put identifier rules at last...</span>
<span class="doccomment">//!         &quot;[1-9][0-9]*(\\.[0-9]+)?([eE][+\\-]?[0-9]+)?&quot;   =&gt; |s, span| Token { span,</span>
<span class="doccomment">//!             kind: TokenKind::Float(s.parse().unwrap()),</span>
<span class="doccomment">//!         },</span>
<span class="doccomment">//!         // Punctuations</span>
<span class="doccomment">//!         &quot;\\+|-|\\*|/|\\(|\\)&quot;                           =&gt; |s, span| Token { span,</span>
<span class="doccomment">//!             kind: TokenKind::Punctuation(String::from(s)),</span>
<span class="doccomment">//!         },</span>
<span class="doccomment">//!         // Identifiers</span>
<span class="doccomment">//!         &quot;[a-zA-Z][_a-zA-Z0-9]*&quot;                         =&gt; |s, span| Token { span,</span>
<span class="doccomment">//!             kind: TokenKind::Identifier(String::from(s)),</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     );</span>
<span class="doccomment">//!     // Notice that when writing regular expressions down we did not use raw string</span>
<span class="doccomment">//!     // literals, which is a common practice, this is because I am simply too lazy</span>
<span class="doccomment">//!     // to handle all types of escape characters -- just use that of rust! Then the</span>
<span class="doccomment">//!     // only thing you may feel uncomfortable is writing `\\`s!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     // We use a lexer state to store the context information.</span>
<span class="doccomment">//!     // A LexerState can be constructed from any char iterators, the simplest being</span>
<span class="doccomment">//!     // calling .chars() of a string.</span>
<span class="doccomment">//!     let mut state = LexerState::from(</span>
<span class="doccomment">//!         &quot;(412 + 321.654) / 768.432 * 34e-1 - sin(30)&quot;.chars()</span>
<span class="doccomment">//!     );</span>
<span class="doccomment">//!     // Proceed until EOF</span>
<span class="doccomment">//!     while !state.eof() {</span>
<span class="doccomment">//!         match lexer.next_token(&amp;mut state) {</span>
<span class="doccomment">//!             Ok(token) =&gt; eprintln!(&quot;{:?}&quot;, token.kind),</span>
<span class="doccomment">//!             Err(msg) =&gt; {</span>
<span class="doccomment">//!                 eprintln!(&quot;Error at {:?}: {}&quot;, state.location, msg);</span>
<span class="doccomment">//!                 break;</span>
<span class="doccomment">//!             }</span>
<span class="doccomment">//!         }</span>
<span class="doccomment">//!     }</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Running this example yields:</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! Punctuation(&quot;(&quot;)</span>
<span class="doccomment">//! Integer(412)</span>
<span class="doccomment">//! Punctuation(&quot;+&quot;)</span>
<span class="doccomment">//! Float(321.654)</span>
<span class="doccomment">//! Punctuation(&quot;)&quot;)</span>
<span class="doccomment">//! Punctuation(&quot;/&quot;)</span>
<span class="doccomment">//! Float(768.432)</span>
<span class="doccomment">//! Punctuation(&quot;*&quot;)</span>
<span class="doccomment">//! Float(3.4)</span>
<span class="doccomment">//! Punctuation(&quot;-&quot;)</span>
<span class="doccomment">//! Identifier(&quot;sin&quot;)</span>
<span class="doccomment">//! Punctuation(&quot;(&quot;)</span>
<span class="doccomment">//! Integer(30)</span>
<span class="doccomment">//! Punctuation(&quot;)&quot;)</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! If we change the input string to an erroneous one like `&quot;(412 + 321.65乱4) / 768.43入2 * 34e-1 - sin(30)&quot;`:</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! Punctuation(&quot;(&quot;)</span>
<span class="doccomment">//! Integer(412)</span>
<span class="doccomment">//! Punctuation(&quot;+&quot;)</span>
<span class="doccomment">//! Float(321.654)</span>
<span class="doccomment">//! Error at Location { line: 1, col: 13 }: Empty input or input cannot be accepted by DFA</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! As you may see particle is different from other lexer gens in that it is not that &quot;battery included&quot;...</span>
<span class="doccomment">//! You still need to define your own token types, and write functions that do conversions.</span>
<span class="doccomment">//! But it offers great flexibility -- the lexer is only responsible for identifying where the token is,</span>
<span class="doccomment">//! its up to you to decide how to deal with them.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! The `define_lexer` macro is still implemented in a somehow dumb way, and you can see some boilerplate code</span>
<span class="doccomment">//! in after =&gt; s, this should be improved after rust allows partial hygiene bending in macros...</span>

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">automatons</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">lexer</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">regex</span>;
<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">span</span>;
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "particle";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script src="../../source-files.js"></script><script src="../../source-script.js"></script><script defer src="../../search-index.js"></script></body></html>